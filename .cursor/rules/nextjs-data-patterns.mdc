---
alwaysApply: true
---

# Next.js Data Fetching & Mutation Patterns

This project follows strict patterns for data handling in Next.js with React Server Components.

## Core Principles

1. **Data Retrieval** - Always use Server Components for fetching data
2. **Data Mutations** - Always use Server Actions for inserts/updates/deletes
3. **Validation** - Always use Zod schemas for data validation
4. **Type Safety** - Server actions must use TypeScript types, NOT FormData

## Data Retrieval with Server Components

Server Components should fetch data directly from the database:

```typescript
// app/decks/page.tsx
import { auth } from '@clerk/nextjs/server';
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq } from 'drizzle-orm';

export default async function DecksPage() {
  const { userId } = await auth();
  
  if (!userId) {
    redirect('/sign-in');
  }
  
  // Fetch data directly in the server component
  const decks = await db.select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
  
  return (
    <div>
      {decks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}
```

## Data Mutations with Server Actions

All database mutations (create, update, delete) must use Server Actions with `"use server"`:

```typescript
// app/actions/deck-actions.ts
"use server";

import { auth } from '@clerk/nextjs/server';
import { db } from '@/db';
import { decksTable } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { revalidatePath } from 'next/cache';
import { z } from 'zod';

// Define Zod schema for validation
const createDeckSchema = z.object({
  name: z.string().min(1, "Name is required").max(255),
  description: z.string().optional(),
});

// Define TypeScript type from Zod schema
type CreateDeckInput = z.infer<typeof createDeckSchema>;

export async function createDeck(input: CreateDeckInput) {
  // Authenticate
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Validate input with Zod
  const validatedData = createDeckSchema.parse(input);
  
  // Insert into database
  const [newDeck] = await db.insert(decksTable)
    .values({
      userId,
      name: validatedData.name,
      description: validatedData.description,
    })
    .returning();
  
  // Revalidate the page cache
  revalidatePath('/decks');
  
  return { success: true, deck: newDeck };
}

export async function deleteDeck(deckId: number) {
  const { userId } = await auth();
  if (!userId) {
    throw new Error("Unauthorized");
  }
  
  // Delete with ownership verification
  await db.delete(decksTable)
    .where(
      and(
        eq(decksTable.id, deckId),
        eq(decksTable.userId, userId)
      )
    );
  
  revalidatePath('/decks');
  
  return { success: true };
}
```

## Calling Server Actions from Client Components

Client components can call server actions using the `useTransition` hook:

```typescript
"use client";

import { useTransition } from 'react';
import { createDeck } from '@/app/actions/deck-actions';
import { Button } from '@/components/ui/button';

export function CreateDeckForm() {
  const [isPending, startTransition] = useTransition();
  
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    
    // Create properly typed object for server action
    const input = {
      name: formData.get('name') as string,
      description: formData.get('description') as string,
    };
    
    startTransition(async () => {
      await createDeck(input);
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="name" required />
      <textarea name="description" />
      <Button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create Deck'}
      </Button>
    </form>
  );
}
```

## Zod Validation Patterns

Always define Zod schemas for data validation:

```typescript
import { z } from 'zod';

// Define schema
const updateCardSchema = z.object({
  cardId: z.number(),
  front: z.string().min(1, "Front text is required"),
  back: z.string().min(1, "Back text is required"),
});

// Infer TypeScript type
type UpdateCardInput = z.infer<typeof updateCardSchema>;

// Use in server action
export async function updateCard(input: UpdateCardInput) {
  // Validation happens here
  const validatedData = updateCardSchema.parse(input);
  
  // ... rest of implementation
}
```

## Rules Summary

✅ **DO:**
- Fetch data in Server Components
- Use Server Actions for all mutations
- Validate with Zod schemas
- Use proper TypeScript types for server action parameters
- Use `revalidatePath()` after mutations to update cache
- Always authenticate in server actions

❌ **DON'T:**
- Use `FormData` as the type for server action parameters
- Fetch data in Client Components (use Server Components instead)
- Mutate data via API routes (use Server Actions instead)
- Skip Zod validation on server action inputs
- Trust client input without validation
